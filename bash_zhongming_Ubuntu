if [ -d ~/.zhongming_completion ]; then
	for FILE in ~/.zhongming_completion/*.bash; do
		. $FILE
	done
fi

# For LuminateWireless.
if [ -f ~/p4/1/main/dev.env ]; then
    . ~/p4/1/main/dev.env
fi

# PS1 taken from https://wiki.archlinux.org/index.php/Color_Bash_Prompt
# TODO(Francois) generate one using https://www.kirsle.net/wizards/ps1.html
PS1="\[\033[01;37m\]\$? \$(if [[ \$? == 0 ]]; then echo \"\[\033[01;32m\]\342\234\223\"; else echo \"\[\033[01;31m\]\342\234\227\"; fi) $(if [[ ${EUID} == 0 ]]; then echo '\[\033[01;31m\]\h'; else echo '\[\033[01;32m\]\u@\h'; fi)\[\033[01;34m\] \w \$\[\033[00m\] "

# Nice colorful git-aware prompt
if [ -f ~/.bash-git-prompt/gitprompt.sh ]; then
    . ~/.bash-git-prompt/gitprompt.sh
    GIT_PROMPT_ONLY_IN_REPO=1
fi

export PATH=~/opt/bin:$PATH
export PATH=~/bin:$PATH
export PATH=~/swift/swift-2.2-RELEASE-ubuntu14.04/usr/bin:$PATH

# Easy ipmi command
export IPMI_PASSWORD=ADMIN
alias it="ipmitool -I lanplus -U ADMIN -E"

# My ICU4C library installs to /opt/icu4c instead /usr/lib
if [ -d /opt/icu4c/lib ]; then
    export PKG_CONFIG_PATH=/opt/icu4c/lib/pkgconfig:$PKG_CONFIG_PATH
    export LD_LIBRARY_PATH=/opt/icu4c/lib:$LD_LIBRARY_PATH
fi

alias eb="gvim ~/.bash_zhongming"
alias sb="source ~/.bash_zhongming"
alias l="ls -F --color=auto"
alias ls="ls -aF --color=auto"
alias ll="ls -alhF --color=auto"

alias grep="grep --color"

alias sshfs-mnt="sshfs -o allow_other,IdentityFile=~/.ssh/zhongming_luminate_gw"

# List untracked files in the current directory
alias p4x="find . -type f | p4 -x- have 2>&1 >/dev/null | cut -d' ' -f1 "

# Darwin-like command line clipboard.
alias pbcopy='xclip -selection clipboard'
alias pbpaste='xclip -selection clipboard -o'

alias ..="cd ..;"
alias up="cd ..;"

# Flash the terminal until the user presses a key. Taken from the 'Example of
# use in shell scripting' section of this wiki page:
#       https://en.wikipedia.org/wiki/ANSI_escape_code
flash () { while true; do printf \\e[?5h; sleep 0.1; printf \\e[?5l; read -s -n1 -t1 && break; done; }

################################################################################
# The following scripts are shamelessly borrowed from Andy (apatti). There are
# several functions defined here:
#   - start-ssh-agent()
#   - ssh-add-key()
#   - ff(), fft(), ffc()
#   - p(), d()
################################################################################

has-ssh-agent() {
    # Return 1 if the current shell can connect to ssh-agent.
    # Return 0 otherwise.
    ssh-add -l &> /dev/null
    ret=$?
    # Note: ssh-add return codes:
    #   0 = success,
    #   1 = specified command fails (e.g., no keys with ssh-add -l)
    #   2 = unable to contact the authentication agent
    if [ $ret -eq 2 ]; then
        return 0
    else
        return 1
    fi
}

start-ssh-agent() {
    #
    # Start an ssh agent if none is running already.
    # * First we try to connect to one via SSH_AUTH_SOCK
    # * If that doesn't work out, we try via the file ssh-agent-environment
    # * And if that doesn't work out either, we just start a fresh one and write
    #   the information about it to ssh-agent-environment for future use.
    #
    # We don't really test for a correct value of SSH_AGENT_PID as the only
    # consequence of not having it set seems to be that one cannot kill
    # the ssh-agent with ssh-agent -k. But starting another one wouldn't
    # help to clean up the old one anyway.
    #
    if [ -n "$SSH_AUTH_SOCK" ]; then
        #
        # First effort: Via SSH_AUTH_SOCK/SSH_AGENT_PID
        #
	    # SSH_AUTH_SOCK is defined, so try to connect to the authentication agent
	    # it should point to. If it succeeds, reset newsshagent.
	    ssh-add -l &> /dev/null
	    if [[ $? != 2 ]]; then
	        echo "SSH agent already running."
	        return 0
	    else
	        echo "Could not contact the ssh-agent pointed at by SSH_AUTH_SOCK, trying more..."
	    fi
    elif [ -f "$sshfile" ]; then
        #
        # Second effort: $sshfile
        #
	    # Load the environment given in $sshfile
        sshfile=~/\.ssh_agent_`hostname`_`whoami`
	    . $sshfile &>/dev/null
	    unset sshfile
	    # Try to contact the ssh-agent
	    ssh-add -l &>/dev/null
	    if [[ $? != 2 ]]; then
	        echo "SSH agent already running; reconfigured the environment."
	        return 0
	    else
	        echo "Could not contact the ssh-agent pointed at by $sshfile."
	    fi
    else
        #
        # And if we haven't found a working one, start a new one.
        #
        #Create a new ssh-agent
        sshfile=~/\.ssh_agent_`hostname`_`whoami`
        echo "Creating new SSH agent."
        ssh-agent -s > $sshfile && . $sshfile
        # Other users must not use or tamper with the $sshfile.
        chmod 700 $sshfile
        unset sshfile
    fi
}

ssh-add-key() {
    ssh-add -l > /dev/null 2>&1
    ret=$?
    if [ $ret -eq 1 ]; then
	    ssh-add
    fi
}

start-ssh-agent &> /dev/null
ssh-add-key

alias ff='find . -name'
function fft()
{
   find . -xtype f ! -name "*~" -name "$1" -exec grep -H $2 \{\} \; ;
   #find . -name "$1" -exec grep -H $2 \{\} \; ;
}


function ffc()
{
   find . -name "*.[ch]*" -exec grep -H $1 \{\} \; ;
}

function ediff()
{
   emacs $1 $2 -f ediffdefaults;
}

function p()
{
   if (($# > 0)); then
      pushd +$1 > /dev/null
   else
      pushd > /dev/null
   fi
   d
}

function d()
{
   let count=0
   for items in `dirs`
   do
      echo $count $items
      let count=$((count+1));
   done
}


################################################################################
# This is the end of scripts borrowed from Andy.
################################################################################
